<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Generator</title>
    <!-- <title>UDELAR Proyecto de Grado</title> -->
    {% load static %}
    <link rel="stylesheet" href="{% static 'shaderator_site/style.css' %}"/>
    <link rel="stylesheet" href="{% static 'shaderator_site/flex.css' %}"/>
    <link rel="stylesheet" href="{% static 'shaderator_site/shader.css' %}"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
</head>
<body class="container">
    <div class="main-container">
        <div class="tab-content-container">
            <div class="tab-container">
                <button class="tab-button active" onclick="openTab(event, 'Canvas')">Canvas</button>
                <button class="tab-button" onclick="openTab(event, 'Code')">Code</button>
            </div>
            <div id="Canvas" class="tab-content" style="display: block;">
                <div class="divcanvas">
                    <canvas id="canvas"></canvas>
                    <div class="playpause">â–¶</div>
                </div>
            </div>
            <div id="Code" class="tab-content" style="display: none;">
                <div class="code-container">
                    <textarea id="shaderCode" cols="55" rows="20" readonly>
                        // GLSL Shader code will be displayed here
                    </textarea>
                </div>
            </div>
        </div>
    </div>
</body>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script>

	if (window.location.hostname !== '127.0.0.1') {
		console.log = function() {};
	}

    // Get the CSRF token from the cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    const csrftoken = getCookie('csrftoken');

    "use strict";

    let messageToSend = ''; // The message to send
    let sendMessages = true; // Flag to control message sending
    let codeToStore = ''; // To store the generated code
    var program;
    let compiled = false;

    // Get WebGL context
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    // The Vertex Shader never changes
    const vs = `
        // an attribute will receive data from a buffer
        attribute vec4 a_position;

        // all shaders have a main function
        void main() {

        // gl_Position is a special variable a vertex shader
        // is responsible for setting
        gl_Position = a_position;
        }
    `;
    // Function to initialize WebGL program
    function initWebGLProgram() {
        /** @type {HTMLCanvasElement} */
        // Check if WebGL context is available
        if (!gl) {
            console.error('Unable to initialize WebGL. Your browser may not support it.');
            return;
        }

        // WebGL program initialization code here...
        // Example: Clearing the canvas with a color
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    // Function to disable the input field
    function disableInputField() {
        document.getElementById('messageInput').disabled = true;
    }

    // Function to enable the input field
    function enableInputField() {
        document.getElementById('messageInput').disabled = false;
    }

    // Get the content element
    const contentElement = document.getElementById('canvas');

    // Function to update the content dynamically
    function updateContent(newContent) {
        contentElement.textContent = newContent;
    }

    // Function to continuously send the same message to the server
    function sendMessagesToServer(attempts) {
        // obtain button element for later use
        button = document.getElementById('sendMessageButton');
        storeButton = document.getElementById('storeButton');
        storeButton.innerHTML = 'Store Result';
        // Check if message sending is enabled
        if (sendMessages) {
            if (messageToSend !== '') {
                // Send the message to the server
                disableStoreButton();
                console.log('Sending message to server...');
                fetch('/start/shader/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken // Include the CSRF token
                    },
                    body: JSON.stringify({ prompt: messageToSend })
                })
                .then(response => {
                    console.log('Received response:', response);
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Parsed JSON data:', data);
                    if (data.error) {
                        throw new Error(data.error);
                    
                    console.log('Received API response from server for prompt ID:', data.prompt_id);}
                    console.log('Received API response from server:', data.shader_code);
                    const res = compile_shader(gl, data.shader_code, data.prompt_id);
                    const compiled_ok = res[0];
                    const program_ok = res[1];

                    if (compiled_ok) {
                        console.log('Shader code compiled successfully.');
                        sendMessages = false; // Stop sending messages
                        canvas_main(gl, program_ok);
                        enableInputField();
                        enableStoreButton();
                        codeToStore = data.shader_code;
                        button.innerHTML = 'Send Message';
                        button.disabled = false;
                        const textArea = document.getElementById('shaderCode');
                        textArea.innerHTML = data.shader_code;

                    } else {
                        console.log('Shader code did not compile. Continuing to send...');
                        console.log('attempt nro:'+attempts)
                        if (attempts < 2) {
                            attempts+=1;
                            sendMessagesToServer(attempts);
                        }
                        else{
                            alert("Too many unsuccesfull attempts, try another prompt");
                            enableInputField();
                            sendMessages = false;
                            button.innerHTML = 'Send Message';
                            button.disabled = false;
                        }
                    }
                })
                .catch(error => {
                    console.log("data result error");
                    console.error('Error:', error);
                    enableInputField();
                    button.innerHTML = 'Send Message';
                    button.disabled = false;
                });
            } else {
                console.error('Message is empty. Stopping message sending.');
                sendMessages = false; // Stop sending messages
                enableInputField();
                button.innerHTML = 'Send Message';
                button.disabled = false;
            }
        }
    }

    // Event listener for Send Message button
    document.getElementById('sendMessageButton').addEventListener('click', function() {
        // Retrieve message from input field
        const messageInput = document.getElementById('messageInput');
        messageToSend = messageInput.value.trim();

        sendMessages = true; // Start sending messages
        this.innerHTML = '<div class="loading"></div>';
        this.disabled = true;
        sendMessagesToServer(0);
    });

    function compile_shader(gl, gpt_code, prompt_id) {
        let compiled_successfully = false;
        let program = null;
        let error_message = '';

        try {
            // Compile the vertex shader (vs)
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vs);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw new Error(`Vertex Shader Error: ${gl.getShaderInfoLog(vertexShader)}`);
            }

            // Compile the fragment shader (gpt_code)
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, gpt_code);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw new Error(`Fragment Shader Error: ${gl.getShaderInfoLog(fragmentShader)}`);
            }

            // Link both shaders into a program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error(`Program Link Error: ${gl.getProgramInfoLog(program)}`);
            }

            compiled_successfully = true;
        } catch (error) {
            console.log('ERROR COMPILING SHADER!!!');
            console.log(error);
            error_message = error.message || error.toString();
        }

        // Send the result to the server for storage
        store_shader_record(gpt_code, prompt_id, compiled_successfully, error_message);

        return [compiled_successfully, program];
    }

    
    function store_shader_record(gpt_code, prompt_id, compiled_successfully, error_message) {
        fetch('/start/store_shader_record/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')  // Make sure to include the CSRF token for Django
            },
            body: JSON.stringify({
                code: gpt_code,
                prompt_id: prompt_id,
                compiled_successfully: compiled_successfully,
                error_message: error_message
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('Shader record stored:', data);
        })
        .catch(error => {
            console.error('Error storing shader record:', error);
        });
    }

    // Event listener for the store button
    document.getElementById('storeButton').addEventListener('click', function () {
        // Store in the data base the result
        // Send the compiled shader code to the server for storage
        
        this.innerHTML = '<div class="loading"></div>';
        this.disabled = true;

        let ratingInput = Number(document.getElementById('ratingSlider').value);
        fetch('/start/store_shader/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken // Include the CSRF token
            },
            body: JSON.stringify({  shader_code: codeToStore,
                                    prompt: messageToSend,
                                    rating: ratingInput })
        })
        .then(response => response.json())
        .then(result => {
            console.log('Shader code stored successfully:', result);
            disableStoreButton();
            this.innerText = "Saved!";
        })
        .catch(error => {
            console.error('Error storing shader code:', error);
            this.innerHTML = 'Store Result';
            this.disabled = false;
        });
    });

    function updateRatingValue(value) {
        document.getElementById('ratingValue').innerText = value;
        console.log('rating value:');
        console.log(Number(document.getElementById('ratingSlider').value));
        // document.getElementById('storeButton').disabled = (value == 0);
    }
    // Function to disable the stpore button
    function disableStoreButton() {
        document.getElementById('storeButton').disabled = true;
    }

    // Function to enable the store button
    function enableStoreButton() {
        document.getElementById('storeButton').disabled = false;
    }

    function openTab(evt, tabName) {
            var i, tabcontent, tabbuttons;
            
            // Hide all tab content
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            // Remove the active class from all buttons
            tabbuttons = document.getElementsByClassName("tab-button");
            for (i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].className = tabbuttons[i].className.replace(" active", "");
            }

            // Show the selected tab content and add the active class to the corresponding button
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
    ////////////////////////////
    // Canvas management code //
    ////////////////////////////
    function canvas_main(gl, program) {

        // look up where the vertex data needs to go.
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

        // look up uniform locations
        const resolutionLocation = gl.getUniformLocation(program, "iResolution");
        const mouseLocation = gl.getUniformLocation(program, "iMouse");
        const timeLocation = gl.getUniformLocation(program, "iTime");

        // Create a buffer to put three 2d clip space points in
        const positionBuffer = gl.createBuffer();

        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // fill it with a 2 triangles that cover clipspace
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  // first triangle
            1, -1,
            -1,  1,
            -1,  1,  // second triangle
            1, -1,
            1,  1,
        ]), gl.STATIC_DRAW);

        const playpauseElem = document.querySelector('.playpause');
        const inputElem = document.querySelector('.divcanvas');
        inputElem.addEventListener('mouseover', requestFrame);
        inputElem.addEventListener('mouseout', cancelFrame);

        let mouseX = 0;
        let mouseY = 0;

        function setMousePosition(e) {
            const rect = inputElem.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
        }

        inputElem.addEventListener('mousemove', setMousePosition);
        inputElem.addEventListener('touchstart', (e) => {
            e.preventDefault();
            playpauseElem.classList.add('playpausehide');
            requestFrame();
        }, { passive: false });
        inputElem.addEventListener('touchmove', (e) => {
            e.preventDefault();
            setMousePosition(e.touches[0]);
        }, { passive: false });
        inputElem.addEventListener('touchend', (e) => {
            e.preventDefault();
            playpauseElem.classList.remove('playpausehide');
            cancelFrame();
        }, { passive: false });

        let requestId;
        function requestFrame() {
            if (!requestId) {
                requestId = requestAnimationFrame(render);
            }
        }
        function cancelFrame() {
            if (requestId) {
                cancelAnimationFrame(requestId);
                requestId = undefined;
            }
        }

        let then = 0;
        let time = 0;

        function render(now) {
            requestId = undefined;
            now *= 0.001;  // convert to seconds
            const elapsedTime = Math.min(now - then, 0.1);
            time += elapsedTime;
            then = now;

            webglUtils.resizeCanvasToDisplaySize(gl.canvas);

            // Tell WebGL how to convert from clip space to pixels
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // Tell it to use our program (pair of shaders)
            gl.useProgram(program);

            // Turn on the attribute
            gl.enableVertexAttribArray(positionAttributeLocation);

            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            gl.vertexAttribPointer(
                positionAttributeLocation,
                2,          // 2 components per iteration
                gl.FLOAT,   // the data is 32bit floats
                false,      // don't normalize the data
                0,          // 0 = move forward size * sizeof(type) each iteration to get the next position
                0,          // start at the beginning of the buffer
            );

            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform2f(mouseLocation, mouseX, mouseY);
            gl.uniform1f(timeLocation, time);

            gl.drawArrays(
                gl.TRIANGLES,
                0,     // offset
                6,     // num vertices to process
            );

            requestFrame();
        }

        requestFrame();
        requestAnimationFrame(cancelFrame);
    }

    // Function to update WebGL content
    function updateWebGLContent(gpt_code) {
        // Check if WebGL context is available
        if (!gl) {
            console.error('WebGL context is not available.');
            return;
        }

        // WebGL content update code here...
        // Example: Redrawing the scene with new data or parameters
        gl.clearColor(Math.random(), Math.random(), Math.random(), 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Additional WebGL drawing commands here...
        canvas_main(gl, program);
    }

    // Initialize WebGL program on page load
    window.addEventListener('load', initWebGLProgram);

    ////////////////////////////

</script>
</html>
