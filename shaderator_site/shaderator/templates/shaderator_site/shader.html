<!-- shader_app/templates/shader_app/shader.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demokritos - Shader Generator</title>
    <!-- <title>UDELAR Proyecto de Grado</title> -->
    {% load static %}
    <link rel="icon" type="image/x-icon" href="{% static 'favicon.ico' %}">
    <link rel="stylesheet" href="{% static 'shaderator_site/style.css' %}"/>
    <link rel="stylesheet" href="{% static 'shaderator_site/flex.css' %}"/>
    <link rel="stylesheet" href="{% static 'shaderator_site/shader.css' %}"/>
    <link rel="stylesheet" href="{% static 'shaderator_site/home-button.css' %}"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
</head>
<body>
    <div class="header-container">
        <!-- <a href="{% url 'download_corpus' %}" class="header-button left-button">Download Corpus</a> -->
        <a href="/start/" class="header-button home-button">üè† Home</a>
    </div>
    <div class="main-container">
        <!-- First Row with Two Equal Columns -->
        <div class="row first-row">

            <!-- Second Column: Text Area, Send Button, Rating System -->
            <div class="column">
                <div class="textarea-container">
                    <textarea cols="55" type="text" id="messageInput" placeholder="Enter prompt"></textarea>
                </div>
                <div class="button-container">
                    {% csrf_token %}
                    <button class="button" id="sendMessageButton">Send Message</button>
                </div>
                <div>
                    <p class="sec_text"> You can play with the code generated and see the result live!</p>
                </div>
            </div>
            <!-- New Second Column -->
            <div class="column">    
                <p class="sec_text">Collaborate by giving it a score and storing it!</p>
                <div class="rating-container">
                    <label class="sec_text" for="ratingSlider">Rating:</label>
                    <div style="padding-top:10px">
                        <input type="range" id="ratingSlider" class="slider" min="0" max="10" value="0" oninput="updateRatingValue(this.value)">
                    </div>
                    <span id="ratingValue">0</span>
                </div>
                <div class="button-container" style="padding-top:20px">
                    <button class="button" id="storeButton" disabled>Store Result</button>
                </div>
            </div>
        </div>

        <!-- Second and Third Rows for Canvas and Code Container -->
        <div class="tab-content-container row second-row">
            <div class="tab-container">
                <button class="tab-button active" onclick="openTab(event, 'CanvasTab')">Canvas</button>
                <button class="tab-button" onclick="openTab(event, 'Code')">Code</button>
            </div>
            <div id="CanvasTab" class="tab-content active">
                <div class="divcanvas">
                    <canvas id="canvas" onclick="togglePlayPause()"></canvas>
                    <div id="overlay" class="overlay">‚è∏</div> <!-- Overlay icon -->
                </div>
            </div>
            <div id="Code" class="tab-content">
                <div class="code-container">
                    <textarea id="shaderCode" cols="55" rows="20" readonly>
                        // GLSL Shader code will be displayed here
                    </textarea>
                    <div id="errorMessage" class="error-message">
                        <!-- Error display -->
                    </div> 
                </div>
            </div>
        </div>             
        
    </div>
</body>


<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script>

	if (window.location.hostname !== '127.0.0.1') {
		console.log = function() {};
	}

    // Get the CSRF token from the cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    const csrftoken = getCookie('csrftoken');

    "use strict";

    let messageToSend = ''; // The message to send
    let sendMessages = true; // Flag to control message sending
    let codeToStore = ''; // To store the generated code
    // let compiled = false;

    // Get WebGL context
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    // The Vertex Shader never changes
    const vs = `
        // an attribute will receive data from a buffer
        attribute vec4 a_position;

        // all shaders have a main function
        void main() {

        // gl_Position is a special variable a vertex shader
        // is responsible for setting
        gl_Position = a_position;
        }
    `;
    // Function to initialize WebGL program
    function initWebGLProgram() {
        /** @type {HTMLCanvasElement} */
        // Check if WebGL context is available
        if (!gl) {
            console.error('Unable to initialize WebGL. Your browser may not support it.');
            return;
        }

        // WebGL program initialization code here...
        // Example: Clearing the canvas with a color
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    // Function to disable the input field
    function disableInputField() {
        document.getElementById('messageInput').disabled = true;
    }

    // Function to enable the input field
    function enableInputField() {
        document.getElementById('messageInput').disabled = false;
    }

    // Get the content element
    const contentElement = document.getElementById('canvas');

    // Function to update the content dynamically
    function updateContent(newContent) {
        contentElement.textContent = newContent;
    }

    function updateShaderCode(newCode) {
        const shaderCodeTextarea = document.getElementById('shaderCode');
        
        // Remove readonly
        shaderCodeTextarea.removeAttribute('readonly');
        
        // Update the text
        shaderCodeTextarea.value = newCode;
    }


    // Function to continuously send the same message to the server
    function sendMessagesToServer(attempts) {
        // obtain button element for later use
        makeCodeNotEditable();
        const textArea = document.getElementById('shaderCode');
        textArea.innerHTML = '';
        button = document.getElementById('sendMessageButton');
        storeButton = document.getElementById('storeButton');
        storeButton.innerHTML = 'Store Result';
        // Check if message sending is enabled
        if (sendMessages) {
            if (messageToSend !== '') {
                // Send the message to the server
                disableStoreButton();
                console.log('Sending message to server...');
                fetch('/start/shader/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken // Include the CSRF token
                    },
                    body: JSON.stringify({ prompt: messageToSend })
                })
                .then(response => {
                    console.log('Received response:', response);
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Parsed JSON data:', data);
                    if (data.error) {
                        throw new Error(data.error);
                    
                    console.log('Received API response from server for prompt ID:', data.prompt_id);}
                    console.log('Received API response from server:', data.shader_code);

                    // Update the shader code in the textarea FIRST
                    updateShaderCode(data.shader_code);

                    const res = compile_shader(gl, data.shader_code);
                    const compiled_ok = res[0];
                    const program_ok = res[1];
                    const error_message= res[2];
                    
                    // Send the result to the server for storage
                    store_shader_record(data.shader_code, data.prompt_id, compiled_ok, error_message);

                    if (compiled_ok) {
                        console.log('Shader code compiled successfully.');
                        sendMessages = false; // Stop sending messages
                        canvas_main(gl, program_ok);
                        globalProgram = program_ok;
                        enableInputField();
                        enableStoreButton();
                        codeToStore = data.shader_code;
                        button.innerHTML = 'Send Message';
                        button.disabled = false;
                        // const textArea = document.getElementById('shaderCode');
                        updateShaderCode(data.shader_code);
                        makeCodeEditable();

                    } else {
                        console.log('Shader code did not compile. Continuing to send...');
                        console.log('attempt nro:'+attempts)
                        if (attempts < 2) {
                            attempts+=1;
                            sendMessagesToServer(attempts);
                        }
                        else{
                            alert("That one didn‚Äôt quite work out! Give it another shot with a different prompt!");
                            enableInputField();
                            sendMessages = false;
                            button.innerHTML = 'Send Message';
                            button.disabled = false;
                        }
                    }
                })
                .catch(error => {
                    console.log("data result error");
                    console.error('Error:', error);
                    enableInputField();
                    button.innerHTML = 'Send Message';
                    button.disabled = false;
                });
            } else {
                console.error('Message is empty. Stopping message sending.');
                sendMessages = false; // Stop sending messages
                enableInputField();
                button.innerHTML = 'Send Message';
                button.disabled = false;
            }
        }
    }

    // Event listener for Send Message button
    document.getElementById('sendMessageButton').addEventListener('click', function() {
        // Retrieve message from input field
        const messageInput = document.getElementById('messageInput');
        messageToSend = messageInput.value.trim();

        sendMessages = true; // Start sending messages
        this.innerHTML = '<div class="loading"></div>';
        this.disabled = true;
        sendMessagesToServer(0);
    });

    function compile_shader(gl, gpt_code) {
        let compiled_successfully = false;
        let program = null;
        let error_message = '';

        try {
            // Compile the vertex shader (vs)
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vs);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw new Error(`Vertex Shader Error: ${gl.getShaderInfoLog(vertexShader)}`);
            }

            // Compile the fragment shader (gpt_code)
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, gpt_code);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw new Error(`Fragment Shader Error: ${gl.getShaderInfoLog(fragmentShader)}`);
            }

            // Link both shaders into a program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error(`Program Link Error: ${gl.getProgramInfoLog(program)}`);
            }

            compiled_successfully = true;
        } catch (error) {
            console.log('ERROR COMPILING SHADER!!!');
            console.log(error);
            error_message = error.message || error.toString();
        }

        return [compiled_successfully, program, errorMessage];
    }

    
    function store_shader_record(gpt_code, prompt_id, compiled_successfully, error_message) {
        fetch('/start/store_shader_record/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')  // Make sure to include the CSRF token for Django
            },
            body: JSON.stringify({
                code: gpt_code,
                prompt_id: prompt_id,
                compiled_successfully: compiled_successfully,
                error_message: error_message
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('Shader record stored:', data);
        })
        .catch(error => {
            console.error('Error storing shader record:', error);
        });
    }

    // Store generated shader
    document.getElementById('storeButton').addEventListener('click', function () {
        // Store in the data base the result
        // Send the compiled shader code to the server for storage
        
        this.innerHTML = '<div class="loading"></div>';
        this.disabled = true;

        let ratingInput = Number(document.getElementById('ratingSlider').value);
        fetch('/start/store_shader/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken // Include the CSRF token
            },
            body: JSON.stringify({  shader_code: codeToStore,
                                    prompt: messageToSend,
                                    rating: ratingInput })
        })
        .then(response => response.json())
        .then(result => {
            console.log('Shader code stored successfully:', result);
            disableStoreButton();
            this.innerText = "Saved!";
        })
        .catch(error => {
            console.error('Error storing shader code:', error);
            this.innerHTML = 'Store Result';
            this.disabled = false;
        });
    });

    function updateRatingValue(value) {
        document.getElementById('ratingValue').innerText = value;
        console.log('rating value:');
        console.log(Number(document.getElementById('ratingSlider').value));
        // document.getElementById('storeButton').disabled = (value == 0);
    }
    // Function to disable the stpore button
    function disableStoreButton() {
        document.getElementById('storeButton').disabled = true;
    }

    // Function to enable the store button
    function enableStoreButton() {
        document.getElementById('storeButton').disabled = false;
    }

    function openTab(evt, tabName) {
        const canvasTab = document.getElementById("CanvasTab");
        const codeTab = document.getElementById("Code");
        const tabButtons = document.getElementsByClassName("tab-button");

        // Reset active state for buttons
        for (let button of tabButtons) {
            button.classList.remove("active");
        }

        // Set active state for the clicked button
        evt.currentTarget.classList.add("active");

        if (tabName === "Code") {
            // Show Code tab as an overlay
            codeTab.classList.add("active");
        } else {
            // Hide the Code tab overlay
            codeTab.classList.remove("active");
        }
    }

    function makeCodeEditable() {
        const codeTextarea = document.getElementById('shaderCode');
        codeTextarea.removeAttribute('readonly'); // Remove the readonly attribute
        codeTextarea.style.border = '2px solid #0f0'; // Optional: Change border color to green
    }

    function makeCodeNotEditable() {
        const codeTextarea = document.getElementById('shaderCode');
        // add readonly attribute
        codeTextarea.setAttribute('readonly', 'readonly');
        codeTextarea.style.border = '0px solid #0f0'; // Optional: Change border color to green
    }

    ////////////////////////////
    // Canvas management code //
    ////////////////////////////

    // Global control variables
    let requestId = null;
    let isPlaying = false;
    let time = 0;
    let then = 0;
    let mouseX = 0;
    let mouseY = 0;

    // WebGL global references
    let globalGL = null;
    let globalProgram = null;
    let globalPositionBuffer = null;
    let globalPositionAttributeLocation = null;
    let globalResolutionLocation = null;
    let globalMouseLocation = null;
    let globalTimeLocation = null;

    // Global function: Toggle Play/Pause
    function togglePlayPause() {
        console.log('toggle is being used');
        if (isPlaying) {
            cancelFrame(); // Stop animation
            overlay.textContent = '‚ñ∂'; // Show play icon when paused
            overlay.style.opacity = "1"; // Show overlay
        } else {
            requestFrame(); // Resume animation
            overlay.textContent = '‚è∏'; // Show pause icon when playing
            setTimeout(() => {
                overlay.style.opacity = "0"; // Hide overlay after a moment
            }, 1000);
        }
        isPlaying = !isPlaying;
    }

    // Global function: Request animation frame
    function requestFrame() {
        if (!requestId) {
            requestId = requestAnimationFrame(render);
        }
    }

    // Global function: Cancel animation frame
    function cancelFrame() {
        if (requestId) {
            cancelAnimationFrame(requestId);
            requestId = null;
        }
    }

    // Global function: WebGL rendering loop
    function render(now) {
        if (!globalGL || !globalProgram) return; // Ensure WebGL is initialized

        requestId = null; // Allow new requests
        now *= 0.001;  // Convert to seconds
        const elapsedTime = Math.min(now - then, 0.1); // Limit time step to avoid jumps
        time += elapsedTime;
        then = now;

        // Resize canvas if needed
        webglUtils.resizeCanvasToDisplaySize(globalGL.canvas);
        globalGL.viewport(0, 0, globalGL.canvas.width, globalGL.canvas.height);

        // Use WebGL program
        globalGL.useProgram(globalProgram);

        // Enable attribute and set buffer
        globalGL.enableVertexAttribArray(globalPositionAttributeLocation);
        globalGL.bindBuffer(globalGL.ARRAY_BUFFER, globalPositionBuffer);
        globalGL.vertexAttribPointer(globalPositionAttributeLocation, 2, globalGL.FLOAT, false, 0, 0);

        // Set uniforms
        globalGL.uniform2f(globalResolutionLocation, globalGL.canvas.width, globalGL.canvas.height);
        globalGL.uniform2f(globalMouseLocation, mouseX, mouseY);
        globalGL.uniform1f(globalTimeLocation, time);

        // Draw shader
        globalGL.drawArrays(globalGL.TRIANGLES, 0, 6);

        // **Continue rendering only if playing**
        if (isPlaying) {
            requestFrame();
        }
    }

    // **Main function to initialize WebGL**
    function canvas_main(gl, program) {
        globalGL = gl;
        globalProgram = program;

        // Attribute and uniform locations
        globalPositionAttributeLocation = gl.getAttribLocation(program, "a_position");
        globalResolutionLocation = gl.getUniformLocation(program, "iResolution");
        globalMouseLocation = gl.getUniformLocation(program, "iMouse");
        globalTimeLocation = gl.getUniformLocation(program, "iTime");

        // Buffer setup
        globalPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, globalPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,   1, -1,   1, 1,
        ]), gl.STATIC_DRAW);

        // Mouse tracking
        const inputElem = document.querySelector('.divcanvas');
        inputElem.addEventListener('mousemove', (e) => {
            const rect = inputElem.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = rect.height - (e.clientY - rect.top) - 1;
        });

        // Attach play/pause toggle to the canvas
        // document.getElementById('canvas').addEventListener('click', togglePlayPause);

        // Start rendering by default
        isPlaying = true;
        requestFrame();
    }

    // Function to update WebGL content
    function updateWebGLContent(newCode) {
        if (!gl) {
            console.error('WebGL context is not available.');
            return;
        }

        // Compile new shader code
        const [compiledSuccessfully, program, errorMessage] = compile_shader(gl, newCode);

        if (!compiledSuccessfully) {
            // Display compilation error in the Code tab
            document.getElementById('errorMessage').textContent = `Compilation Error:\n${errorMessage}`;
            console.error('Shader Compilation Failed:', errorMessage);
        } else {
            // Clear previous errors if successful
            codeToStore = newCode;
            console.log('new code to store:', codeToStore);
            document.getElementById('errorMessage').textContent = '';
            globalProgram = program; // Update the global WebGL program
            canvas_main(gl, globalProgram); // Restart rendering with the new shader
        }
    }
    
    let debounceTimer;

    document.getElementById('shaderCode').addEventListener('input', function () {
        clearTimeout(debounceTimer);
        
        debounceTimer = setTimeout(() => {
            const newCode = this.value.trim(); // Get updated shader code
            updateWebGLContent(newCode); // Compile & render new shader
        }, 300); // 300ms debounce to avoid unnecessary recompilations
    });

    // Initialize WebGL program on page load
    window.addEventListener('load', initWebGLProgram);

    ////////////////////////////

</script>
</html>
